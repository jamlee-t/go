sha,filename,url,lines,title,comment,priority,category,additional,id,private
"dbf30d88f3b8c8129fb0978dda7452cc931b75d6","/src/cmd/link/internal/ld/pe.go","","290:0-303:1","Windows PE: Tmp 和 Dll","DLL 代表1个动态库，Imp 代表 Import，也就是指符号。","1","Separation of concerns","","35877807-e32e-4ae4-9a90-22b0ede1cc3e","0"
"dbf30d88f3b8c8129fb0978dda7452cc931b75d6","/src/run.bat","","29:0-37:8","注释测试脚本以支持windows 编译运行","","0","Code Walkthrough","","0ed475e6-ce3a-40d7-ac61-b358eda4811d","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/pe.go","","1194:2-1211:3","实例化 Dll 和 Imp 结构，Dll 代表动态库，Imp 代码动态库的符号","for 循环遍历所有符号，只挑选可达且是`sym.SDYNIMPORT`的符号。该符号关联到 dnylib。\n\n1. 因为多个符号关联1个Dll，Dll 被前面的符号初始化过。已经加在 Dll 链表里直接获取到 Dll，添加符号到 Dll 下的 Imp (符号）链表上。\n\n2.如果 Dll 不在链表中，创建新 Dll加到 Dll链表。并且新 Dll 也关联了第一个符号。\n\n\n那么这里 Dll 是哪里定义的指令呢？\n1. 在位置 `src/runtime/os_windows.go:63`, `go:cgo_import_dynamic` 指令定义dll和符。例如：\n```go\n//go:cgo_import_dynamic runtime._AddVectoredContinueHandler AddVectoredContinueHandler%2 ""kernel32.dll""\n\n```","1","Code Walkthrough","","4a86adff-2306-4e89-963e-fa3e6907b7bb","0"
b04ae46565724b4e1e3a146c83245727bb47cc54,/src/cmd/link/internal/ld/pe.go,,1254:2-1266:3, `.windynamic` 管理子符号,"内部链接，所以创建符号 `.windynamic`, 并把 Dll 中的符号放到这个子符号下",0,Code Walkthrough,,29a09a28-f105-4397-a613-af9e5acde009,0
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/loader/loader.go","","1360:18-1360:28","SetSymSect 记录符号对应的 Section 的 index","Loader 的 symSects 字段符号对应的 Section 的 ","0","Code Walkthrough","","6a974da4-1961-4d7e-af15-f6901fb12879","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/data.go","","2646:0-2647:57",".text 和 .etext 符号是 VA，指向 .text 的开始和结束位置","符号的地址是 VA","0","Code Walkthrough","","dafcdd54-8913-4156-98dc-7f03d2719814","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/typelink.go","","41:0-68:2","创建符号 runtime.typelink 和 runtime.itablink ","这两个符号可以认为是一个数组类型的。里面都是重定位的条目，重定位的Offset是以符号的位置为基址。","0","","","ed3a66a7-2408-49cc-9228-a875475491ea","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/data.go","","2423:0-2423:31","创建符号 go:buildinfo.ref 和 go:buildinfo","go:buildinfo.ref 设置地址指向 gobuildinfo，类型 RODATA\ngo:buildinfo 指向数据块","0","Code Walkthrough","","d2101ce6-e051-4e8f-bfe8-b0f9f648c9de","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/main.go","","423:0-427:40","创建 pclntab 数据","创建的符号有：\n1. runtime.findfunctab, RODATA。符号内容基于函数延迟创建。\n","0","","","5b76db23-a03b-480c-b9f8-86f0b791b7a8","0"
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/debug/elf/file.go,,452:17-452:27,section数量为 0 触发特殊条件,shnum == 0 触发特殊规则。当实际节头数量 ≥ SHN_LORESERVE（即 0xff00）时：\ne_shnum 的值会被设为 0（表示节数量过大，无法直接存储在文件头中）。真实数量存储在索引 0 的节头的 sh_size 字段（即第一个节头条目的 sh_size 成员）。\n\n,0,Code Walkthrough,,bc61229c-5abe-4ea9-a02c-2bb39316b6cb,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/obj.go,,46:2-46:10,创建 goobj 文件入口,dumpobj1 创建 goobj 文件,0,Code Walkthrough,,6cb206bf-6047-4435-846f-48dbad656c5b,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/obj.go,,127:5-127:18,创建链接文件: _go_.o,,0,Code Walkthrough,,60eb83dc-38ba-4c5a-8596-1e804e9cddda,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/obj/objfile.go,,122:0-122:0,写入 objfile 内容,,0,Code Walkthrough,,1fba733b-74c3-48f6-9ef1-31bc26ac5479,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/obj/objfile.go,,93:0-98:0,写入包自定义符号,会创建：\n1. src/cmd/internal/goobj/funcinfo.go:19。他是编译器生成的,0,Code Walkthrough,,0bb6d7c7-14b3-4a01-9df3-aa66edcd6ee8,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/goobj/objfile.go,,437:0-455:1,符号的辅助信息类型,比如 Funcinfo 引用一个特殊没有名称SDATA符号。,0,Code Walkthrough,,8b0e7830-ca9e-43d1-a665-e6143c152fab,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/noder/noder.go,,67:17-67:22,控制前面的并发，使得结果完成之后才访问 p.file,,0,Code Walkthrough,,3baf0212-016d-4824-a2c7-e9a719bde85b,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/main.go,,219:1-219:29,添加 go:cuinfo.packagename.main 符号到 ctxt.hash map 里,,0,Code Walkthrough,,3865f52f-7efe-4b95-8c31-5ae52b635300,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/main.go,,222:1-222:20,base.Ctxt 的 Funcs 和 Vars 数组给添加符号,1. types.Types 类型缓存\n2. typecheck.LookupRuntimeFunc 给 base.Ctxt 创建运行时的符号。函数参数定义在 typecheck/mkbuilt.go 生成里面 _builtin。\n,0,Code Walkthrough,,faa5e8aa-faa5-4a72-a878-03a2ae654264,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/typecheck/typecheck.go,,17:0-34:0,本包的核心检查函数，在 noder 包中检查 ir 的表示,"typecheck包的入口是分散的，通过多个公共函数提供服务，这些函数在编译器的IR构建和处理阶段被广泛调用，形成了编译器类型检查的重要组成部分。\n\n原代码有注释,这个用在读取 export data 时：\nthe source files are typechecked twice: once before writing the export data using types2, and again after reading the export data using gc/typecheck.",0,Code Walkthrough,,e21c82a0-493b-4fcd-9725-6fdcd32a3c74,0


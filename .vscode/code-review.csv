sha,filename,url,lines,title,comment,priority,category,additional,id,private
"dbf30d88f3b8c8129fb0978dda7452cc931b75d6","/src/cmd/link/internal/ld/pe.go","","290:0-303:1","Windows PE: Tmp 和 Dll","DLL 代表1个动态库，Imp 代表 Import，也就是指符号。","1","Separation of concerns","","35877807-e32e-4ae4-9a90-22b0ede1cc3e","0"
"dbf30d88f3b8c8129fb0978dda7452cc931b75d6","/src/run.bat","","29:0-37:8","注释测试脚本以支持windows 编译运行","","0","Code Walkthrough","","0ed475e6-ce3a-40d7-ac61-b358eda4811d","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/pe.go","","1194:2-1211:3","实例化 Dll 和 Imp 结构，Dll 代表动态库，Imp 代码动态库的符号","for 循环遍历所有符号，只挑选可达且是`sym.SDYNIMPORT`的符号。该符号关联到 dnylib。\n\n1. 因为多个符号关联1个Dll，Dll 被前面的符号初始化过。已经加在 Dll 链表里直接获取到 Dll，添加符号到 Dll 下的 Imp (符号）链表上。\n\n2.如果 Dll 不在链表中，创建新 Dll加到 Dll链表。并且新 Dll 也关联了第一个符号。\n\n\n那么这里 Dll 是哪里定义的指令呢？\n1. 在位置 `src/runtime/os_windows.go:63`, `go:cgo_import_dynamic` 指令定义dll和符。例如：\n```go\n//go:cgo_import_dynamic runtime._AddVectoredContinueHandler AddVectoredContinueHandler%2 ""kernel32.dll""\n\n```","1","Code Walkthrough","","4a86adff-2306-4e89-963e-fa3e6907b7bb","0"
b04ae46565724b4e1e3a146c83245727bb47cc54,/src/cmd/link/internal/ld/pe.go,,1254:2-1266:3, `.windynamic` 管理子符号,"内部链接，所以创建符号 `.windynamic`, 并把 Dll 中的符号放到这个子符号下",0,Code Walkthrough,,29a09a28-f105-4397-a613-af9e5acde009,0
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/loader/loader.go","","1360:18-1360:28","SetSymSect 记录符号对应的 Section 的 index","Loader 的 symSects 字段符号对应的 Section 的 ","0","Code Walkthrough","","6a974da4-1961-4d7e-af15-f6901fb12879","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/data.go","","2646:0-2647:57",".text 和 .etext 符号是 VA，指向 .text 的开始和结束位置","符号的地址是 VA","0","Code Walkthrough","","dafcdd54-8913-4156-98dc-7f03d2719814","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/typelink.go","","41:0-68:2","创建符号 runtime.typelink 和 runtime.itablink ","这两个符号可以认为是一个数组类型的。里面都是重定位的条目，重定位的Offset是以符号的位置为基址。","0","","","ed3a66a7-2408-49cc-9228-a875475491ea","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/data.go","","2423:0-2423:31","创建符号 go:buildinfo.ref 和 go:buildinfo","go:buildinfo.ref 设置地址指向 gobuildinfo，类型 RODATA\ngo:buildinfo 指向数据块","0","Code Walkthrough","","d2101ce6-e051-4e8f-bfe8-b0f9f648c9de","0"
"3717708d473529310feadcf07a6d4f9cb5e59c7f","/src/cmd/link/internal/ld/main.go","","423:0-427:40","创建 pclntab 数据","创建的符号有：\n1. runtime.findfunctab, RODATA。符号内容基于函数延迟创建。\n","0","","","5b76db23-a03b-480c-b9f8-86f0b791b7a8","0"
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/debug/elf/file.go,,452:17-452:27,section数量为 0 触发特殊条件,shnum == 0 触发特殊规则。当实际节头数量 ≥ SHN_LORESERVE（即 0xff00）时：\ne_shnum 的值会被设为 0（表示节数量过大，无法直接存储在文件头中）。真实数量存储在索引 0 的节头的 sh_size 字段（即第一个节头条目的 sh_size 成员）。\n\n,0,Code Walkthrough,,bc61229c-5abe-4ea9-a02c-2bb39316b6cb,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/obj.go,,46:2-46:10,创建 goobj 文件入口,dumpobj1 创建 goobj 文件,0,Code Walkthrough,,6cb206bf-6047-4435-846f-48dbad656c5b,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/obj.go,,127:5-127:18,创建链接文件: _go_.o,,0,Code Walkthrough,,60eb83dc-38ba-4c5a-8596-1e804e9cddda,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/obj/objfile.go,,122:0-122:0,写入 objfile 内容,,0,Code Walkthrough,,1fba733b-74c3-48f6-9ef1-31bc26ac5479,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/obj/objfile.go,,93:0-98:0,写入包自定义符号,会创建：\n1. src/cmd/internal/goobj/funcinfo.go:19。他是编译器生成的,0,Code Walkthrough,,0bb6d7c7-14b3-4a01-9df3-aa66edcd6ee8,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/internal/goobj/objfile.go,,437:0-455:1,符号的辅助信息类型,比如 Funcinfo 引用一个特殊没有名称SDATA符号。,0,Code Walkthrough,,8b0e7830-ca9e-43d1-a665-e6143c152fab,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/noder/noder.go,,67:17-67:22,控制前面的并发，使得结果完成之后才访问 p.file,,0,Code Walkthrough,,3baf0212-016d-4824-a2c7-e9a719bde85b,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/main.go,,219:1-219:29,添加 go:cuinfo.packagename.main 符号到 ctxt.hash map 里,,0,Code Walkthrough,,3865f52f-7efe-4b95-8c31-5ae52b635300,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/gc/main.go,,222:1-222:20,base.Ctxt 的 Funcs 和 Vars 数组给添加符号,1. types.Types 类型缓存\n2. typecheck.LookupRuntimeFunc 给 base.Ctxt 创建运行时的符号。函数参数定义在 typecheck/mkbuilt.go 生成里面 _builtin。\n,0,Code Walkthrough,,faa5e8aa-faa5-4a72-a878-03a2ae654264,0
f14214d07de7242c9a6a33186260220b3a5a78b5,/src/cmd/compile/internal/typecheck/typecheck.go,,17:0-34:0,本包的核心检查函数，在 noder 包中检查 ir 的表示,"typecheck包的入口是分散的，通过多个公共函数提供服务，这些函数在编译器的IR构建和处理阶段被广泛调用，形成了编译器类型检查的重要组成部分。\n\n原代码有注释,这个用在读取 export data 时：\nthe source files are typechecked twice: once before writing the export data using types2, and again after reading the export data using gc/typecheck.",0,Code Walkthrough,,e21c82a0-493b-4fcd-9725-6fdcd32a3c74,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/gc/main.go,,205:1-205:14,rttype 通过反射从 abi.Type 中创建出来 types.Type,-,0,Code Walkthrough,,6c59074c-97ec-4b65-a291-76a809798b65,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/ssagen/ssa.go,,81:18-81:43,types.NewPtr 对 types.Types[types.TINTER] 对象的 cache 字段设置了值,,0,Code Walkthrough,,0c7e9fa4-d396-4778-846f-60df75bfba3d,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/gc/main.go,,245:1-249:17,闭包捕获循环变量时处理,loopvar.ForCapture 会修改 IR 的表示结构。,0,Code Walkthrough,,5fbecad7-62c8-428a-a9e8-05fbd833db61,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/gc/main.go,,283:1-283:30,仅编译 runtime 包时执行,,0,Code Walkthrough,,0b76f92d-b99b-49aa-aa61-8ae2fd6128b6,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/gc/main.go,,271:1-271:40,TODO：或许是打印循环变量修改日志,,0,Code Walkthrough,,59b250e8-2452-43e1-97a8-935bd9845906,0
2d1f18815f86ee9a4f9f991e81e77d72e912a575,/src/cmd/compile/internal/gc/main.go,,256:1-256:25,TODO：两种不同 ABI 的函数需要互相调用时，就需要 ABI 包装器来进行转换,Go 编译器中存在两种不同的调用约定（ABI）：\n\nABI0: 传统的基于栈的调用约定，主要用于汇编代码和 C 互操作\nABIInternal: Go 内部的基于寄存器的调用约定，用于 Go 源码编译的函数\n\n当这两种不同 ABI 的函数需要互相调用时，就需要 ABI 包装器来进行转换,0,Code Walkthrough,,e9fb5138-3b69-4891-a05e-7bf3fbf2ac93,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/doc.go,,5:0-5:2,翻译,Compile（通常以go tool compile方式调用）用于编译单个 Go 包，该包由命令行中指定的文件组成。随后，它会生成一个目标文件，文件名以第一个源文件的基名加上.o 后缀构成。\n这个目标文件之后可以与其他目标文件合并为一个包归档文件，或者直接传递给链接器（go tool link）。如果使用 - pack 参数调用编译器，它会直接生成归档文件，跳过中间的目标文件。\n,0,Code Walkthrough,,c0ef6188-0aca-4f59-a7cf-e31dbb4d93c4,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/doc.go,,13:0-13:3,翻译,生成的文件包含关于该包导出的符号的类型信息，以及关于该包从其他包导入的符号所使用的类型的信息。因此，在编译包 P 的客户端 C 时，无需读取 P 的依赖项的文件，只需 P 的编译输出即可。\n,0,Code Walkthrough,,b276f4b0-99ec-45ee-8880-c8248a0b33a7,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/noder/posmap.go,,14:5-14:11,转 syntax.Pos 到 src.Pos,这两个 pos 功能类似\n1.支持记录node的物理源文件位置\n2.支持记录node的物理源文件和逻辑源文件位置。原因是 line 指令介入了\n\nPos 和 PosBase 类之间循环定义。判断是否有 line 指令介入，通过 base.pos.base == base。它在 func (base *PosBase) IsFileBase() bool 中用到。,0,Code Walkthrough,,855d825a-60c7-4c80-a3aa-c36d69bd93cf,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/noder/noder.go,,65:1-65:13,posMap 缓存转换 syntax.Pos 转 src.Pos 的结果,它不是全量理解转换的，仅仅起到缓存的作用,0,Code Walkthrough,,9003ae6a-3abc-40db-a3e3-9436ebee0414,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/types2/resolver.go,,231:2-231:102,fileScope 是 pkgScope 的 子Scope,两个不要搞混了,0,Code Walkthrough,,d21612be-d9b2-46bf-b2b3-29a39e91f4ff,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/types2/resolver.go,,335:5-335:50,import 声明写入 fileScope。其他声明则写入 pkg.Scope,,0,Code Walkthrough,,615885b3-6d7a-4811-8fa5-c85b501038db,0
3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/types2/resolver.go,,475:1-475:33,保证导入的包名和已有的声明无冲突,,0,Code Walkthrough,,1348be3b-c21b-4733-a210-16bea8f2ec89,0

3052bda7fcfa9dfc0ad8b16f91883c614179c3d7,/src/cmd/compile/internal/types2/recording.go,,138:22-138:31,记录 info 信息。info 信息是 type2.Check 方法的返回值之一,,0,Code Walkthrough,,5fb6ba66-a5a7-4237-942c-0127dc5b0d65,0

